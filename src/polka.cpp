// This file is generated by kxml_compiler from polka.xml.
// All changes you do to this file will be lost.
/*
    This file is part of KDE.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
    USA.
*/

#include "polka.h"

#include <QtDebug>
#include <QFile>
#include <QDomDocument>
#include <QtCore/QTextStream>
#include <QtCore/QtDebug>
#include <QtCore/QFile>

QString indent( int n = 0 )
{
  static int i = 0;
  i += n;
  QString space;
  return space.fill( ' ', i );
}

void IdentityPosition::setId( const QString &v )
{
  mId = v;
}

QString IdentityPosition::id() const
{
  return mId;
}

bool IdentityPosition::isValid() const
{
  return !mId.isEmpty();
}

void IdentityPosition::setX( int v )
{
  mX = v;
}

int IdentityPosition::x() const
{
  return mX;
}

void IdentityPosition::setY( int v )
{
  mY = v;
}

int IdentityPosition::y() const
{
  return mY;
}

IdentityPosition IdentityPosition::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "identity_position" ) {
    qCritical() << "Expected 'identity_position', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return IdentityPosition();
  }

  IdentityPosition result = IdentityPosition();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "x" ) {
      result.setX( e.text().toInt() );
    }
    else if ( e.tagName() == "y" ) {
      result.setY( e.text().toInt() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString IdentityPosition::writeElement()
{
  QString xml;
  xml += indent() + "<identity_position>\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  xml += indent() + "<x>" + QString::number( x() ) + "</x>\n";
  xml += indent() + "<y>" + QString::number( y() ) + "</y>\n";
  indent( -2 );
  xml += indent() + "</identity_position>\n";
  return xml;
}


void GroupView::setId( const QString &v )
{
  mId = v;
}

QString GroupView::id() const
{
  return mId;
}

bool GroupView::isValid() const
{
  return !mId.isEmpty();
}

void GroupView::addIdentityPosition( const IdentityPosition &v )
{
  mIdentityPositionList.append( v );
}

void GroupView::setIdentityPositionList( const IdentityPosition::List &v )
{
  mIdentityPositionList = v;
}

IdentityPosition::List GroupView::identityPositionList() const
{
  return mIdentityPositionList;
}

IdentityPosition GroupView::findIdentityPosition( const QString &id, Flags flags )
{
  foreach( IdentityPosition v, mIdentityPositionList ) {
    if ( v.id() == id ) return v;
  }
  IdentityPosition v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool GroupView::insert( const IdentityPosition &v )
{
  int i = 0;
  for( ; i < mIdentityPositionList.size(); ++i ) {
    if ( mIdentityPositionList[i].id() == v.id() ) {
      mIdentityPositionList[i] = v;
      return true;
    }
  }
  if ( i == mIdentityPositionList.size() ) {
    addIdentityPosition( v );
  }
  return true;
}

bool GroupView::remove( const IdentityPosition &v )
{
  IdentityPosition::List::Iterator it;
  for( it = mIdentityPositionList.begin(); it != mIdentityPositionList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mIdentityPositionList.end() ) {
    mIdentityPositionList.erase( it );
  }
  return true;
}

GroupView GroupView::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "group_view" ) {
    qCritical() << "Expected 'group_view', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return GroupView();
  }

  GroupView result = GroupView();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "identity_position" ) {
      bool ok;
      IdentityPosition o = IdentityPosition::parseElement( e, &ok );
      if ( ok ) result.addIdentityPosition( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString GroupView::writeElement()
{
  QString xml;
  xml += indent() + "<group_view>\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  foreach( IdentityPosition e, identityPositionList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</group_view>\n";
  return xml;
}


void Comment::setId( const QString &v )
{
  mId = v;
}

QString Comment::id() const
{
  return mId;
}

void Comment::setText( const QString &v )
{
  mText = v;
}

QString Comment::text() const
{
  return mText;
}

Comment Comment::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "comment" ) {
    qCritical() << "Expected 'comment', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Comment();
  }

  Comment result = Comment();

  result.setText( element.text() );
  result.setId( element.attribute( "id" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Comment::writeElement()
{
  QString xml;
  if ( !text().isEmpty() ) {
    xml += indent() + "<comment id=\"" + id() + "\">" + text() + "</comment>\n";
  }
  return xml;
}


void Comments::addComment( const Comment &v )
{
  mCommentList.append( v );
}

void Comments::setCommentList( const Comment::List &v )
{
  mCommentList = v;
}

Comment::List Comments::commentList() const
{
  return mCommentList;
}

Comment Comments::findComment( const QString &id, Flags flags )
{
  foreach( Comment v, mCommentList ) {
    if ( v.id() == id ) return v;
  }
  Comment v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Comments::insert( const Comment &v )
{
  int i = 0;
  for( ; i < mCommentList.size(); ++i ) {
    if ( mCommentList[i].id() == v.id() ) {
      mCommentList[i] = v;
      return true;
    }
  }
  if ( i == mCommentList.size() ) {
    addComment( v );
  }
  return true;
}

bool Comments::remove( const Comment &v )
{
  Comment::List::Iterator it;
  for( it = mCommentList.begin(); it != mCommentList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mCommentList.end() ) {
    mCommentList.erase( it );
  }
  return true;
}

Comments Comments::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "comments" ) {
    qCritical() << "Expected 'comments', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Comments();
  }

  Comments result = Comments();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "comment" ) {
      bool ok;
      Comment o = Comment::parseElement( e, &ok );
      if ( ok ) result.addComment( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Comments::writeElement()
{
  QString xml;
  xml += indent() + "<comments>\n";
  indent( 2 );
  foreach( Comment e, commentList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</comments>\n";
  return xml;
}


void Attribute::setType( const QString &v )
{
  mType = v;
}

QString Attribute::type() const
{
  return mType;
}

void Attribute::setKey( const QString &v )
{
  mKey = v;
}

QString Attribute::key() const
{
  return mKey;
}

void Attribute::setValue( const QString &v )
{
  mValue = v;
}

QString Attribute::value() const
{
  return mValue;
}

Attribute Attribute::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "attribute" ) {
    qCritical() << "Expected 'attribute', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Attribute();
  }

  Attribute result = Attribute();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "key" ) {
      result.setKey( e.text() );
    }
    else if ( e.tagName() == "value" ) {
      result.setValue( e.text() );
    }
  }

  result.setType( element.attribute( "type" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Attribute::writeElement()
{
  QString xml;
  xml += indent() + "<attribute type=\"" + type() + "\">\n";
  indent( 2 );
  if ( !key().isEmpty() ) {
    xml += indent() + "<key>" + key() + "</key>\n";
  }
  if ( !value().isEmpty() ) {
    xml += indent() + "<value>" + value() + "</value>\n";
  }
  indent( -2 );
  xml += indent() + "</attribute>\n";
  return xml;
}


void ExtendedAttributes::addAttribute( const Attribute &v )
{
  mAttributeList.append( v );
}

void ExtendedAttributes::setAttributeList( const Attribute::List &v )
{
  mAttributeList = v;
}

Attribute::List ExtendedAttributes::attributeList() const
{
  return mAttributeList;
}

ExtendedAttributes ExtendedAttributes::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "extended_attributes" ) {
    qCritical() << "Expected 'extended_attributes', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return ExtendedAttributes();
  }

  ExtendedAttributes result = ExtendedAttributes();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "attribute" ) {
      bool ok;
      Attribute o = Attribute::parseElement( e, &ok );
      if ( ok ) result.addAttribute( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString ExtendedAttributes::writeElement()
{
  QString xml;
  xml += indent() + "<extended_attributes>\n";
  indent( 2 );
  foreach( Attribute e, attributeList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</extended_attributes>\n";
  return xml;
}


void Link::setId( const QString &v )
{
  mId = v;
}

QString Link::id() const
{
  return mId;
}

bool Link::isValid() const
{
  return !mId.isEmpty();
}

void Link::setLinkType( const QString &v )
{
  mLinkType = v;
}

QString Link::linkType() const
{
  return mLinkType;
}

void Link::setUrl( const QString &v )
{
  mUrl = v;
}

QString Link::url() const
{
  return mUrl;
}

Link Link::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "link" ) {
    qCritical() << "Expected 'link', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Link();
  }

  Link result = Link();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "link_type" ) {
      result.setLinkType( e.text() );
    }
    else if ( e.tagName() == "url" ) {
      result.setUrl( e.text() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Link::writeElement()
{
  QString xml;
  xml += indent() + "<link>\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  if ( !linkType().isEmpty() ) {
    xml += indent() + "<link_type>" + linkType() + "</link_type>\n";
  }
  if ( !url().isEmpty() ) {
    xml += indent() + "<url>" + url() + "</url>\n";
  }
  indent( -2 );
  xml += indent() + "</link>\n";
  return xml;
}


void Links::addLink( const Link &v )
{
  mLinkList.append( v );
}

void Links::setLinkList( const Link::List &v )
{
  mLinkList = v;
}

Link::List Links::linkList() const
{
  return mLinkList;
}

Link Links::findLink( const QString &id, Flags flags )
{
  foreach( Link v, mLinkList ) {
    if ( v.id() == id ) return v;
  }
  Link v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Links::insert( const Link &v )
{
  int i = 0;
  for( ; i < mLinkList.size(); ++i ) {
    if ( mLinkList[i].id() == v.id() ) {
      mLinkList[i] = v;
      return true;
    }
  }
  if ( i == mLinkList.size() ) {
    addLink( v );
  }
  return true;
}

bool Links::remove( const Link &v )
{
  Link::List::Iterator it;
  for( it = mLinkList.begin(); it != mLinkList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mLinkList.end() ) {
    mLinkList.erase( it );
  }
  return true;
}

Links Links::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "links" ) {
    qCritical() << "Expected 'links', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Links();
  }

  Links result = Links();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "link" ) {
      bool ok;
      Link o = Link::parseElement( e, &ok );
      if ( ok ) result.addLink( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Links::writeElement()
{
  QString xml;
  xml += indent() + "<links>\n";
  indent( 2 );
  foreach( Link e, linkList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</links>\n";
  return xml;
}


void Note::setId( const QString &v )
{
  mId = v;
}

QString Note::id() const
{
  return mId;
}

void Note::setCreatedAt( const QString &v )
{
  mCreatedAt = v;
}

QString Note::createdAt() const
{
  return mCreatedAt;
}

void Note::setUpdatedAt( const QString &v )
{
  mUpdatedAt = v;
}

QString Note::updatedAt() const
{
  return mUpdatedAt;
}

void Note::setText( const QString &v )
{
  mText = v;
}

QString Note::text() const
{
  return mText;
}

Note Note::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "note" ) {
    qCritical() << "Expected 'note', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Note();
  }

  Note result = Note();

  result.setText( element.text() );
  result.setId( element.attribute( "id" ) );
  result.setCreatedAt( element.attribute( "created_at" ) );
  result.setUpdatedAt( element.attribute( "updated_at" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Note::writeElement()
{
  QString xml;
  if ( !text().isEmpty() ) {
    xml += indent() + "<note id=\"" + id() + "\" created_at=\"" + createdAt() + "\" updated_at=\"" + updatedAt() + "\">" + text() + "</note>\n";
  }
  return xml;
}


void Notes::addNote( const Note &v )
{
  mNoteList.append( v );
}

void Notes::setNoteList( const Note::List &v )
{
  mNoteList = v;
}

Note::List Notes::noteList() const
{
  return mNoteList;
}

Note Notes::findNote( const QString &id, Flags flags )
{
  foreach( Note v, mNoteList ) {
    if ( v.id() == id ) return v;
  }
  Note v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Notes::insert( const Note &v )
{
  int i = 0;
  for( ; i < mNoteList.size(); ++i ) {
    if ( mNoteList[i].id() == v.id() ) {
      mNoteList[i] = v;
      return true;
    }
  }
  if ( i == mNoteList.size() ) {
    addNote( v );
  }
  return true;
}

bool Notes::remove( const Note &v )
{
  Note::List::Iterator it;
  for( it = mNoteList.begin(); it != mNoteList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mNoteList.end() ) {
    mNoteList.erase( it );
  }
  return true;
}

Notes Notes::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "notes" ) {
    qCritical() << "Expected 'notes', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Notes();
  }

  Notes result = Notes();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "note" ) {
      bool ok;
      Note o = Note::parseElement( e, &ok );
      if ( ok ) result.addNote( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Notes::writeElement()
{
  QString xml;
  xml += indent() + "<notes>\n";
  indent( 2 );
  foreach( Note e, noteList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</notes>\n";
  return xml;
}


void Relation::setRelationType( const QString &v )
{
  mRelationType = v;
}

QString Relation::relationType() const
{
  return mRelationType;
}

void Relation::setTarget( const QString &v )
{
  mTarget = v;
}

QString Relation::target() const
{
  return mTarget;
}

Relation Relation::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "relation" ) {
    qCritical() << "Expected 'relation', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Relation();
  }

  Relation result = Relation();

  result.setRelationType( element.attribute( "relation_type" ) );
  result.setTarget( element.attribute( "target" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Relation::writeElement()
{
  QString xml;
  xml += indent() + "<relation relation_type=\"" + relationType() + "\" target=\"" + target() + "\"/>\n";
  return xml;
}


void Relations::addRelation( const Relation &v )
{
  mRelationList.append( v );
}

void Relations::setRelationList( const Relation::List &v )
{
  mRelationList = v;
}

Relation::List Relations::relationList() const
{
  return mRelationList;
}

Relations Relations::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "relations" ) {
    qCritical() << "Expected 'relations', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Relations();
  }

  Relations result = Relations();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "relation" ) {
      bool ok;
      Relation o = Relation::parseElement( e, &ok );
      if ( ok ) result.addRelation( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Relations::writeElement()
{
  QString xml;
  xml += indent() + "<relations>\n";
  indent( 2 );
  foreach( Relation e, relationList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</relations>\n";
  return xml;
}


void Address::setId( const QString &v )
{
  mId = v;
}

QString Address::id() const
{
  return mId;
}

bool Address::isValid() const
{
  return !mId.isEmpty();
}

void Address::setLabel( const QString &v )
{
  mLabel = v;
}

QString Address::label() const
{
  return mLabel;
}

Address Address::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "address" ) {
    qCritical() << "Expected 'address', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Address();
  }

  Address result = Address();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "label" ) {
      result.setLabel( e.text() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Address::writeElement()
{
  QString xml;
  xml += indent() + "<address>\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  if ( !label().isEmpty() ) {
    xml += indent() + "<label>" + label() + "</label>\n";
  }
  indent( -2 );
  xml += indent() + "</address>\n";
  return xml;
}


void Addresses::addAddress( const Address &v )
{
  mAddressList.append( v );
}

void Addresses::setAddressList( const Address::List &v )
{
  mAddressList = v;
}

Address::List Addresses::addressList() const
{
  return mAddressList;
}

Address Addresses::findAddress( const QString &id, Flags flags )
{
  foreach( Address v, mAddressList ) {
    if ( v.id() == id ) return v;
  }
  Address v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Addresses::insert( const Address &v )
{
  int i = 0;
  for( ; i < mAddressList.size(); ++i ) {
    if ( mAddressList[i].id() == v.id() ) {
      mAddressList[i] = v;
      return true;
    }
  }
  if ( i == mAddressList.size() ) {
    addAddress( v );
  }
  return true;
}

bool Addresses::remove( const Address &v )
{
  Address::List::Iterator it;
  for( it = mAddressList.begin(); it != mAddressList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mAddressList.end() ) {
    mAddressList.erase( it );
  }
  return true;
}

Addresses Addresses::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "addresses" ) {
    qCritical() << "Expected 'addresses', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Addresses();
  }

  Addresses result = Addresses();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "address" ) {
      bool ok;
      Address o = Address::parseElement( e, &ok );
      if ( ok ) result.addAddress( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Addresses::writeElement()
{
  QString xml;
  xml += indent() + "<addresses>\n";
  indent( 2 );
  foreach( Address e, addressList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</addresses>\n";
  return xml;
}


void Phone::setComment( const QString &v )
{
  mComment = v;
}

QString Phone::comment() const
{
  return mComment;
}

void Phone::setId( const QString &v )
{
  mId = v;
}

QString Phone::id() const
{
  return mId;
}

bool Phone::isValid() const
{
  return !mId.isEmpty();
}

void Phone::setPhoneType( const QString &v )
{
  mPhoneType = v;
}

QString Phone::phoneType() const
{
  return mPhoneType;
}

void Phone::setPhoneNumber( const QString &v )
{
  mPhoneNumber = v;
}

QString Phone::phoneNumber() const
{
  return mPhoneNumber;
}

Phone Phone::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "phone" ) {
    qCritical() << "Expected 'phone', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Phone();
  }

  Phone result = Phone();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "phone_type" ) {
      result.setPhoneType( e.text() );
    }
    else if ( e.tagName() == "phone_number" ) {
      result.setPhoneNumber( e.text() );
    }
  }

  result.setComment( element.attribute( "comment" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Phone::writeElement()
{
  QString xml;
  xml += indent() + "<phone comment=\"" + comment() + "\">\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  if ( !phoneType().isEmpty() ) {
    xml += indent() + "<phone_type>" + phoneType() + "</phone_type>\n";
  }
  if ( !phoneNumber().isEmpty() ) {
    xml += indent() + "<phone_number>" + phoneNumber() + "</phone_number>\n";
  }
  indent( -2 );
  xml += indent() + "</phone>\n";
  return xml;
}


void Phones::addPhone( const Phone &v )
{
  mPhoneList.append( v );
}

void Phones::setPhoneList( const Phone::List &v )
{
  mPhoneList = v;
}

Phone::List Phones::phoneList() const
{
  return mPhoneList;
}

Phone Phones::findPhone( const QString &id, Flags flags )
{
  foreach( Phone v, mPhoneList ) {
    if ( v.id() == id ) return v;
  }
  Phone v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Phones::insert( const Phone &v )
{
  int i = 0;
  for( ; i < mPhoneList.size(); ++i ) {
    if ( mPhoneList[i].id() == v.id() ) {
      mPhoneList[i] = v;
      return true;
    }
  }
  if ( i == mPhoneList.size() ) {
    addPhone( v );
  }
  return true;
}

bool Phones::remove( const Phone &v )
{
  Phone::List::Iterator it;
  for( it = mPhoneList.begin(); it != mPhoneList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mPhoneList.end() ) {
    mPhoneList.erase( it );
  }
  return true;
}

Phones Phones::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "phones" ) {
    qCritical() << "Expected 'phones', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Phones();
  }

  Phones result = Phones();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "phone" ) {
      bool ok;
      Phone o = Phone::parseElement( e, &ok );
      if ( ok ) result.addPhone( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Phones::writeElement()
{
  QString xml;
  xml += indent() + "<phones>\n";
  indent( 2 );
  foreach( Phone e, phoneList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</phones>\n";
  return xml;
}


void Picture::setUpdatedAt( const QString &v )
{
  mUpdatedAt = v;
}

QString Picture::updatedAt() const
{
  return mUpdatedAt;
}

void Picture::setPictureType( const QString &v )
{
  mPictureType = v;
}

QString Picture::pictureType() const
{
  return mPictureType;
}

void Picture::setId( const QString &v )
{
  mId = v;
}

QString Picture::id() const
{
  return mId;
}

bool Picture::isValid() const
{
  return !mId.isEmpty();
}

void Picture::setUrl( const QString &v )
{
  mUrl = v;
}

QString Picture::url() const
{
  return mUrl;
}

Picture Picture::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "picture" ) {
    qCritical() << "Expected 'picture', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Picture();
  }

  Picture result = Picture();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "url" ) {
      result.setUrl( e.text() );
    }
  }

  result.setUpdatedAt( element.attribute( "updated_at" ) );
  result.setPictureType( element.attribute( "picture_type" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Picture::writeElement()
{
  QString xml;
  xml += indent() + "<picture updated_at=\"" + updatedAt() + "\" picture_type=\"" + pictureType() + "\">\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  if ( !url().isEmpty() ) {
    xml += indent() + "<url>" + url() + "</url>\n";
  }
  indent( -2 );
  xml += indent() + "</picture>\n";
  return xml;
}


void Pictures::addPicture( const Picture &v )
{
  mPictureList.append( v );
}

void Pictures::setPictureList( const Picture::List &v )
{
  mPictureList = v;
}

Picture::List Pictures::pictureList() const
{
  return mPictureList;
}

Picture Pictures::findPicture( const QString &id, Flags flags )
{
  foreach( Picture v, mPictureList ) {
    if ( v.id() == id ) return v;
  }
  Picture v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Pictures::insert( const Picture &v )
{
  int i = 0;
  for( ; i < mPictureList.size(); ++i ) {
    if ( mPictureList[i].id() == v.id() ) {
      mPictureList[i] = v;
      return true;
    }
  }
  if ( i == mPictureList.size() ) {
    addPicture( v );
  }
  return true;
}

bool Pictures::remove( const Picture &v )
{
  Picture::List::Iterator it;
  for( it = mPictureList.begin(); it != mPictureList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mPictureList.end() ) {
    mPictureList.erase( it );
  }
  return true;
}

Pictures Pictures::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "pictures" ) {
    qCritical() << "Expected 'pictures', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Pictures();
  }

  Pictures result = Pictures();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "picture" ) {
      bool ok;
      Picture o = Picture::parseElement( e, &ok );
      if ( ok ) result.addPicture( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Pictures::writeElement()
{
  QString xml;
  xml += indent() + "<pictures>\n";
  indent( 2 );
  foreach( Picture e, pictureList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</pictures>\n";
  return xml;
}


void Email::setId( const QString &v )
{
  mId = v;
}

QString Email::id() const
{
  return mId;
}

void Email::setUpdatedAt( const QString &v )
{
  mUpdatedAt = v;
}

QString Email::updatedAt() const
{
  return mUpdatedAt;
}

void Email::setText( const QString &v )
{
  mText = v;
}

QString Email::text() const
{
  return mText;
}

Email Email::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "email" ) {
    qCritical() << "Expected 'email', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Email();
  }

  Email result = Email();

  result.setText( element.text() );
  result.setId( element.attribute( "id" ) );
  result.setUpdatedAt( element.attribute( "updated_at" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Email::writeElement()
{
  QString xml;
  if ( !text().isEmpty() ) {
    xml += indent() + "<email id=\"" + id() + "\" updated_at=\"" + updatedAt() + "\">" + text() + "</email>\n";
  }
  return xml;
}


void Emails::addEmail( const Email &v )
{
  mEmailList.append( v );
}

void Emails::setEmailList( const Email::List &v )
{
  mEmailList = v;
}

Email::List Emails::emailList() const
{
  return mEmailList;
}

Email Emails::findEmail( const QString &id, Flags flags )
{
  foreach( Email v, mEmailList ) {
    if ( v.id() == id ) return v;
  }
  Email v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Emails::insert( const Email &v )
{
  int i = 0;
  for( ; i < mEmailList.size(); ++i ) {
    if ( mEmailList[i].id() == v.id() ) {
      mEmailList[i] = v;
      return true;
    }
  }
  if ( i == mEmailList.size() ) {
    addEmail( v );
  }
  return true;
}

bool Emails::remove( const Email &v )
{
  Email::List::Iterator it;
  for( it = mEmailList.begin(); it != mEmailList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mEmailList.end() ) {
    mEmailList.erase( it );
  }
  return true;
}

Emails Emails::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "emails" ) {
    qCritical() << "Expected 'emails', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Emails();
  }

  Emails result = Emails();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "email" ) {
      bool ok;
      Email o = Email::parseElement( e, &ok );
      if ( ok ) result.addEmail( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Emails::writeElement()
{
  QString xml;
  xml += indent() + "<emails>\n";
  indent( 2 );
  foreach( Email e, emailList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</emails>\n";
  return xml;
}


void Group::setId( const QString &v )
{
  mId = v;
}

QString Group::id() const
{
  return mId;
}

bool Group::isValid() const
{
  return !mId.isEmpty();
}

Group Group::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "group" ) {
    qCritical() << "Expected 'group', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Group();
  }

  Group result = Group();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Group::writeElement()
{
  QString xml;
  xml += indent() + "<group>\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  indent( -2 );
  xml += indent() + "</group>\n";
  return xml;
}


void Groups::addGroup( const Group &v )
{
  mGroupList.append( v );
}

void Groups::setGroupList( const Group::List &v )
{
  mGroupList = v;
}

Group::List Groups::groupList() const
{
  return mGroupList;
}

Group Groups::findGroup( const QString &id, Flags flags )
{
  foreach( Group v, mGroupList ) {
    if ( v.id() == id ) return v;
  }
  Group v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Groups::insert( const Group &v )
{
  int i = 0;
  for( ; i < mGroupList.size(); ++i ) {
    if ( mGroupList[i].id() == v.id() ) {
      mGroupList[i] = v;
      return true;
    }
  }
  if ( i == mGroupList.size() ) {
    addGroup( v );
  }
  return true;
}

bool Groups::remove( const Group &v )
{
  Group::List::Iterator it;
  for( it = mGroupList.begin(); it != mGroupList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mGroupList.end() ) {
    mGroupList.erase( it );
  }
  return true;
}

Groups Groups::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "groups" ) {
    qCritical() << "Expected 'groups', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Groups();
  }

  Groups result = Groups();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "group" ) {
      bool ok;
      Group o = Group::parseElement( e, &ok );
      if ( ok ) result.addGroup( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Groups::writeElement()
{
  QString xml;
  xml += indent() + "<groups>\n";
  indent( 2 );
  foreach( Group e, groupList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</groups>\n";
  return xml;
}


void Name::setUpdatedAt( const QString &v )
{
  mUpdatedAt = v;
}

QString Name::updatedAt() const
{
  return mUpdatedAt;
}

void Name::setText( const QString &v )
{
  mText = v;
}

QString Name::text() const
{
  return mText;
}

Name Name::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "name" ) {
    qCritical() << "Expected 'name', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Name();
  }

  Name result = Name();

  result.setText( element.text() );
  result.setUpdatedAt( element.attribute( "updated_at" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Name::writeElement()
{
  QString xml;
  if ( !text().isEmpty() ) {
    xml += indent() + "<name updated_at=\"" + updatedAt() + "\">" + text() + "</name>\n";
  }
  return xml;
}


void Identity::setId( const QString &v )
{
  mId = v;
}

QString Identity::id() const
{
  return mId;
}

bool Identity::isValid() const
{
  return !mId.isEmpty();
}

void Identity::setGroups( const Groups &v )
{
  mGroups = v;
}

Groups Identity::groups() const
{
  return mGroups;
}

void Identity::setName( const Name &v )
{
  mName = v;
}

Name Identity::name() const
{
  return mName;
}

void Identity::setBirthname( const QString &v )
{
  mBirthname = v;
}

QString Identity::birthname() const
{
  return mBirthname;
}

void Identity::setBirthday( const QDate &v )
{
  mBirthday = v;
}

QDate Identity::birthday() const
{
  return mBirthday;
}

void Identity::setEmails( const Emails &v )
{
  mEmails = v;
}

Emails Identity::emails() const
{
  return mEmails;
}

void Identity::setPictures( const Pictures &v )
{
  mPictures = v;
}

Pictures Identity::pictures() const
{
  return mPictures;
}

void Identity::setPhones( const Phones &v )
{
  mPhones = v;
}

Phones Identity::phones() const
{
  return mPhones;
}

void Identity::setAddresses( const Addresses &v )
{
  mAddresses = v;
}

Addresses Identity::addresses() const
{
  return mAddresses;
}

void Identity::setRelations( const Relations &v )
{
  mRelations = v;
}

Relations Identity::relations() const
{
  return mRelations;
}

void Identity::setNotes( const Notes &v )
{
  mNotes = v;
}

Notes Identity::notes() const
{
  return mNotes;
}

void Identity::setLinks( const Links &v )
{
  mLinks = v;
}

Links Identity::links() const
{
  return mLinks;
}

void Identity::setExtendedAttributes( const ExtendedAttributes &v )
{
  mExtendedAttributes = v;
}

ExtendedAttributes Identity::extendedAttributes() const
{
  return mExtendedAttributes;
}

void Identity::setComments( const Comments &v )
{
  mComments = v;
}

Comments Identity::comments() const
{
  return mComments;
}

Identity Identity::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "identity" ) {
    qCritical() << "Expected 'identity', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Identity();
  }

  Identity result = Identity();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "id" ) {
      result.setId( e.text() );
    }
    else if ( e.tagName() == "groups" ) {
      bool ok;
      Groups o = Groups::parseElement( e, &ok );
      if ( ok ) result.setGroups( o );
    }
    else if ( e.tagName() == "name" ) {
      bool ok;
      Name o = Name::parseElement( e, &ok );
      if ( ok ) result.setName( o );
    }
    else if ( e.tagName() == "birthname" ) {
      result.setBirthname( e.text() );
    }
    else if ( e.tagName() == "birthday" ) {
      result.setBirthday( QDate::fromString( e.text(), Qt::ISODate ) );
    }
    else if ( e.tagName() == "emails" ) {
      bool ok;
      Emails o = Emails::parseElement( e, &ok );
      if ( ok ) result.setEmails( o );
    }
    else if ( e.tagName() == "pictures" ) {
      bool ok;
      Pictures o = Pictures::parseElement( e, &ok );
      if ( ok ) result.setPictures( o );
    }
    else if ( e.tagName() == "phones" ) {
      bool ok;
      Phones o = Phones::parseElement( e, &ok );
      if ( ok ) result.setPhones( o );
    }
    else if ( e.tagName() == "addresses" ) {
      bool ok;
      Addresses o = Addresses::parseElement( e, &ok );
      if ( ok ) result.setAddresses( o );
    }
    else if ( e.tagName() == "relations" ) {
      bool ok;
      Relations o = Relations::parseElement( e, &ok );
      if ( ok ) result.setRelations( o );
    }
    else if ( e.tagName() == "notes" ) {
      bool ok;
      Notes o = Notes::parseElement( e, &ok );
      if ( ok ) result.setNotes( o );
    }
    else if ( e.tagName() == "links" ) {
      bool ok;
      Links o = Links::parseElement( e, &ok );
      if ( ok ) result.setLinks( o );
    }
    else if ( e.tagName() == "extended_attributes" ) {
      bool ok;
      ExtendedAttributes o = ExtendedAttributes::parseElement( e, &ok );
      if ( ok ) result.setExtendedAttributes( o );
    }
    else if ( e.tagName() == "comments" ) {
      bool ok;
      Comments o = Comments::parseElement( e, &ok );
      if ( ok ) result.setComments( o );
    }
  }


  if ( ok ) *ok = true;
  return result;
}

QString Identity::writeElement()
{
  QString xml;
  xml += indent() + "<identity>\n";
  indent( 2 );
  if ( !id().isEmpty() ) {
    xml += indent() + "<id>" + id() + "</id>\n";
  }
  xml += groups().writeElement();
  xml += name().writeElement();
  if ( !birthname().isEmpty() ) {
    xml += indent() + "<birthname>" + birthname() + "</birthname>\n";
  }
  xml += indent() + "<birthday>" + birthday().toString( Qt::ISODate ) + "</birthday>\n";
  xml += emails().writeElement();
  xml += pictures().writeElement();
  xml += phones().writeElement();
  xml += addresses().writeElement();
  xml += relations().writeElement();
  xml += notes().writeElement();
  xml += links().writeElement();
  xml += extendedAttributes().writeElement();
  xml += comments().writeElement();
  indent( -2 );
  xml += indent() + "</identity>\n";
  return xml;
}


void Polka::setSchemaVersion( const QString &v )
{
  mSchemaVersion = v;
}

QString Polka::schemaVersion() const
{
  return mSchemaVersion;
}

void Polka::addIdentity( const Identity &v )
{
  mIdentityList.append( v );
}

void Polka::setIdentityList( const Identity::List &v )
{
  mIdentityList = v;
}

Identity::List Polka::identityList() const
{
  return mIdentityList;
}

Identity Polka::findIdentity( const QString &id, Flags flags )
{
  foreach( Identity v, mIdentityList ) {
    if ( v.id() == id ) return v;
  }
  Identity v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Polka::insert( const Identity &v )
{
  int i = 0;
  for( ; i < mIdentityList.size(); ++i ) {
    if ( mIdentityList[i].id() == v.id() ) {
      mIdentityList[i] = v;
      return true;
    }
  }
  if ( i == mIdentityList.size() ) {
    addIdentity( v );
  }
  return true;
}

bool Polka::remove( const Identity &v )
{
  Identity::List::Iterator it;
  for( it = mIdentityList.begin(); it != mIdentityList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mIdentityList.end() ) {
    mIdentityList.erase( it );
  }
  return true;
}

void Polka::addGroupView( const GroupView &v )
{
  mGroupViewList.append( v );
}

void Polka::setGroupViewList( const GroupView::List &v )
{
  mGroupViewList = v;
}

GroupView::List Polka::groupViewList() const
{
  return mGroupViewList;
}

GroupView Polka::findGroupView( const QString &id, Flags flags )
{
  foreach( GroupView v, mGroupViewList ) {
    if ( v.id() == id ) return v;
  }
  GroupView v;
  if ( flags == AutoCreate ) {
    v.setId( id );
  }
  return v;
}

bool Polka::insert( const GroupView &v )
{
  int i = 0;
  for( ; i < mGroupViewList.size(); ++i ) {
    if ( mGroupViewList[i].id() == v.id() ) {
      mGroupViewList[i] = v;
      return true;
    }
  }
  if ( i == mGroupViewList.size() ) {
    addGroupView( v );
  }
  return true;
}

bool Polka::remove( const GroupView &v )
{
  GroupView::List::Iterator it;
  for( it = mGroupViewList.begin(); it != mGroupViewList.end(); ++it ) {
    if ( (*it).id() == v.id() ) break;
  }
  if ( it != mGroupViewList.end() ) {
    mGroupViewList.erase( it );
  }
  return true;
}

Polka Polka::parseElement( const QDomElement &element, bool *ok )
{
  if ( element.tagName() != "polka" ) {
    qCritical() << "Expected 'polka', got '" << element.tagName() << "'.";
    if ( ok ) *ok = false;
    return Polka();
  }

  Polka result = Polka();

  QDomNode n;
  for( n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
    QDomElement e = n.toElement();
    if ( e.tagName() == "identity" ) {
      bool ok;
      Identity o = Identity::parseElement( e, &ok );
      if ( ok ) result.addIdentity( o );
    }
    else if ( e.tagName() == "group_view" ) {
      bool ok;
      GroupView o = GroupView::parseElement( e, &ok );
      if ( ok ) result.addGroupView( o );
    }
  }

  result.setSchemaVersion( element.attribute( "schemaVersion" ) );

  if ( ok ) *ok = true;
  return result;
}

QString Polka::writeElement()
{
  QString xml;
  xml += indent() + "<polka schemaVersion=\"" + schemaVersion() + "\">\n";
  indent( 2 );
  foreach( Identity e, identityList() ) {
    xml += e.writeElement();
  }
  foreach( GroupView e, groupViewList() ) {
    xml += e.writeElement();
  }
  indent( -2 );
  xml += indent() + "</polka>\n";
  return xml;
}

Polka Polka::parseFile( const QString &filename, bool *ok )
{
  QFile file( filename );
  if ( !file.open( QIODevice::ReadOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    if ( ok ) *ok = false;
    return Polka();
  }

  QString errorMsg;
  int errorLine, errorCol;
  QDomDocument doc;
  if ( !doc.setContent( &file, false, &errorMsg, &errorLine, &errorCol ) ) {
    qCritical() << errorMsg << " at " << errorLine << "," << errorCol;
    if ( ok ) *ok = false;
    return Polka();
  }

  qDebug() << "CONTENT:" << doc.toString();

  bool documentOk;
  Polka c = parseElement( doc.documentElement(), &documentOk );
  if ( ok ) {
    *ok = documentOk;
  }
  return c;
}

bool Polka::writeFile( const QString &filename )
{
  QFile file( filename );
  if ( !file.open( QIODevice::WriteOnly ) ) {
    qCritical() << "Unable to open file '" << filename << "'";
    return false;
  }

  QTextStream ts( &file );
  ts << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
  ts << writeElement();
  file.close();

  return true;
}


